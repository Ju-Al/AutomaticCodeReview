		}
		defer fd.Close()
		w = fd
	}

	typeName := func(n string) string {
		switch n {
		case "String", "ID":
			return "string"
		case "Int":
			return "number"
		case "Boolean":
			return "boolean"
		}

		return n
	}

	fmt.Fprintf(w, "// Code generated by devtools/gqltsgen DO NOT EDIT.\n\n")

	for _, def := range doc.Definitions {
		switch def.Kind {
		case ast.Enum:
			fmt.Fprintf(w, "export enum %s {\n", def.Name)
			for _, e := range def.EnumValues {
				fmt.Fprintf(w, "  %s = '%s',\n", e.Name, e.Name)
			}
			fmt.Fprintf(w, "}\n\n")
		case ast.InputObject, ast.Object:
			fmt.Fprintf(w, "export interface %s {\n", def.Name)
			for _, e := range def.Fields {
				mod := "?"
				if e.Type.NonNull {
					mod = ""
				}
				fmt.Fprintf(w, "  %s: %s\n", e.Name+mod, typeName(e.Type.Name()))
			}
			fmt.Fprintf(w, "}\n\n")
		case ast.Scalar:
			fmt.Fprintf(w, "export type %s = string\n\n", def.Name)
		default:
			log.Fatal("Unsupported kind:", def.Name, def.Kind)
		}
	}
}
